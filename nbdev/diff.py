"""Get ipynb diffs by cell"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/19_diff.ipynb.

# %% auto 0
__all__ = ['read_nb_from_git', 'nbs_pair', 'changed_cells', 'source_diff', 'cell_diffs']

# %% ../nbs/api/19_diff.ipynb
import json
from fastcore.utils import *
from fastcore.meta import delegates
from difflib import unified_diff
from fastgit import Git
from execnb.nbio import *

# %% ../nbs/api/19_diff.ipynb
def read_nb_from_git(
    g:Git, # The git object
    ref, # The git ref to read from (e.g. HEAD)
    path # The path to the notebook in git
)->AttrDict: # The notebook
    "Read notebook from git ref (e.g. HEAD) at path"
    raw = g.show(f'{ref}:{path}', split=False)
    return dict2nb(json.loads(raw))

# %% ../nbs/api/19_diff.ipynb
def nbs_pair(
    nb_path, # Path to the notebook
    ref_a='HEAD', # First git ref (None for working dir)
    ref_b=None # Second git ref (None for working dir)
): # Tuple of two notebooks
    "NBs at two refs; None means working dir. By default provides HEAD and working dir"
    nb_path = Path(nb_path).resolve()
    g = Git(nb_path.parent)
    rel = nb_path.relative_to(g.top())
    nb_a = read_nb_from_git(g, ref_a, str(rel)) if ref_a else read_nb(nb_path)
    nb_b = read_nb_from_git(g, ref_b, str(rel)) if ref_b else read_nb(nb_path)
    return nb_a, nb_b

# %% ../nbs/api/19_diff.ipynb
def _cell_changes(
    nb_path, # Path to the notebook
    fn, # function to call to get dict values
    ref_a='HEAD', # First git ref (None for working dir)
    ref_b=None, # Second git ref (None for working dir)
    adds=True, # Include cells in b but not in a
    changes=True, # Include cells with different content
    dels=False, # Include cells in a but not in b
    metadata=False, # Consider cell metadata when comparing
    outputs=False # Consider cell outputs when comparing
): # Dict of results
    "Apply fn(cell_id, old_content, new_content) to changed cells between two refs"
    nb_a, nb_b = nbs_pair(nb_path, ref_a, ref_b)
    def cell_content(c):
        res = c.get('source', '')
        if metadata: res += '\n# metadata: ' + json.dumps(c.get('metadata', {}), sort_keys=True)
        if outputs: res += '\n# outputs: ' + json.dumps(c.get('outputs', []), sort_keys=True)
        return res
    old = {c['id']: cell_content(c) for c in nb_a.cells}
    new = {c['id']: cell_content(c) for c in nb_b.cells}
    res = {}
    if adds: res |= {cid: fn(cid, '', new[cid]) for cid in new if cid not in old}
    if changes: res |= {cid: fn(cid, old[cid], new[cid]) for cid in new if cid in old and new[cid] != old[cid]}
    if dels: res |= {cid: fn(cid, old[cid], '') for cid in old if cid not in new}
    return res

# %% ../nbs/api/19_diff.ipynb
@delegates(_cell_changes)
def changed_cells(nb_path, **kwargs):
    "Return set of cell IDs for changed/added/deleted cells between two refs"
    def f(cid,o,n): return cid
    return set(_cell_changes(nb_path, f, **kwargs).keys())

# %% ../nbs/api/19_diff.ipynb
def source_diff(
    old_source, # Original source string
    new_source # New source string
): # Unified diff string
    "Return unified diff string for source change"
    return '\n'.join(unified_diff(old_source.splitlines(), new_source.splitlines(), lineterm=''))

# %% ../nbs/api/19_diff.ipynb
@delegates(_cell_changes)
def cell_diffs(nb_path, **kwargs):
    "{cell_id:diff} for changed/added/deleted cells between two refs"
    def f(cid,o,n): return source_diff(o,n)
    return _cell_changes(nb_path, f, **kwargs)
