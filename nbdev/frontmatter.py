"""A YAML and formatted-markdown frontmatter processor"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/09_frontmatter.ipynb.

# %% auto 0
__all__ = ['FrontmatterProc']

# %% ../nbs/api/09_frontmatter.ipynb
from .imports import *
from .process import *
from .doclinks import _nbpath2html

from execnb.nbio import *
from fastcore.imports import *
import yaml

# %% ../nbs/api/09_frontmatter.ipynb
_RE_FM_BASE=r'''^---\s*
(.*?\S+.*?)
---\s*'''

_re_fm_nb = re.compile(_RE_FM_BASE+'$', flags=re.DOTALL)
_re_fm_md = re.compile(_RE_FM_BASE, flags=re.DOTALL)

_RE_FM_AND_MD = r'^#\s+(\S.*?)\s*\n(?:\s*\n)*(?:>\s+(\S.*?)\s*\n(?:\s*\n)*((?:^\s*-\s+[a-zA-Z_][a-zA-Z0-9_]*\s*:\s+.*\s*\n?)*))?\s*(.*?)$'
_re_fm_and_md = re.compile(_RE_FM_AND_MD, flags=re.MULTILINE | re.DOTALL)

def _fm2dict(s:str, nb=True):
    "Load YAML frontmatter into a `dict`"
    re_fm = _re_fm_nb if nb else _re_fm_md
    match = re_fm.search(s.strip())
    return yaml.safe_load(match.group(1)) if match else {}

def _md2dict(s:str):
    "Convert H1 formatted markdown cell to frontmatter dict"
    if '#' not in s: return {}
    # Captures frontmatter and any remaining content
    match = _re_fm_and_md.search(s.strip())
    if not match: return {}
    res = {'title': match.group(1)}
    if match.group(2): res['description'] = match.group(2)
    if match.group(3):
        kv_lines = re.findall(r'^-\s+([a-zA-Z_][a-zA-Z0-9_]*\s*:\s+.*)\s*$', match.group(3), flags=re.MULTILINE)
        if kv_lines:
            try: res.update(yaml.safe_load('\n'.join(kv_lines)))
            except Exception as e: warn(f'Failed to create YAML dict for:\n{kv_lines}\n\n{e}\n')
    
    # Add remaining content if present
    remaining = match.group(4).strip()
    if remaining: res['__remaining'] = remaining
    return res

# %% ../nbs/api/09_frontmatter.ipynb
def _dict2fm(d): return f'---\n{yaml.dump(d)}\n---\n\n'
def _insertfm(nb, fm): nb.cells.insert(0, mk_cell(_dict2fm(fm), 'raw'))

class FrontmatterProc(Processor):
    "A YAML and formatted-markdown frontmatter processor"
    def begin(self): 
        self.fm = getattr(self.nb, 'frontmatter_', {})
        self.is_qmd = hasattr(self.nb, 'path_') and Path(self.nb.path_).suffix == '.qmd'
        
    def _update(self, f, cell):
        s = cell.get('source')
        if not s: return
        d = f(s)
        if not d: return
        remaining = d.pop('__remaining', None)
        self.fm.update(d)
        if remaining:
            new_cell = mk_cell(remaining, 'markdown')
            cell_idx = self.nb.cells.index(cell)
            self.nb.cells.insert(cell_idx + 1, new_cell)
        cell.source = None

    def cell(self, cell):
        if cell.cell_type=='raw': self._update(_fm2dict, cell)
        elif (cell.cell_type=='markdown' and 'title' not in self.fm): self._update(_md2dict, cell)

    def end(self):
        self.nb.frontmatter_ = self.fm
        if not self.fm: return
        if not hasattr(self.nb, 'path_'):
            raise AttributeError('Notebook missing `path_` attribute.\n\nPlease remove any nbdev-related notebook filters '
                                 'from your _quarto.yml file (e.g. `ipynb-filter: [nbdev_filter]`), since they are no '
                                 'longer supported as of nbdev v2.3. See the v2.3 launch post for more information: '
                                 'https://forums.fast.ai/t/upcoming-changes-in-v2-3-edit-now-released/98905.')
        self.fm.update({'output-file': _nbpath2html(Path(self.nb.path_)).name})
        _insertfm(self.nb, self.fm)
